# <center>基础数据结构</center>

## 一、数组和字符串

### 1.1 散列表

散列表，通过将键映射为值从而实现快速查找的数据结构。

一种常见的实现方式，使用一个由链表构成的数组和一个散列函数来实现。插入键和值的时候，按照如下的方法操作：

- 计算散列值，通常是int或者long。不同的键可能会有相同的散列值，因为键是无穷的，int和long是有限的。
- 将散列值映射到数组的索引。可以使用$hash(key) \% array_length$来计算,请注意不同的散列值有可能会被映射到相同的数组索引。
- 数组在此索引处存放的是一个由键值构成一种元素所组成的链表。请将所有映射到这个位置的元素，都放进这个数组位置的链表中。因为存在冲突，必须使用链表：有可能相同的散列值有着不同的键，或者不同的散列值被映射到了同一个索引。

如果想要查找一个元素（键值对），首先通过键计算散列值，在通过散列值计算索引。之后通过查找链表获取键所对应的值。
如果冲突发生很多次，最坏的情况是$O(N)$,N是键的数量。通常可以设置一个不错的实现方式会将冲突数量保持在最低水平，此时时间复杂度是$O(1)$.

另一种情况，可以通过平衡二叉树来实现散列表。查找时间是$O(logN)$.

### 1.2 ArrayList与可变长度数组

在Java中，数组长度是不可变的，在有些其他语言中数组可能是变长的。
当你需要类似于数组、同时提供动态长度的数据结构时，可能会用到ArrayList。
ArrayList是一个可动态调整大小的数组，数据访问时间为$O(1)$.一种典型的实现方法是在数组存满的时候扩容2倍，每次扩容用时$O(N)$,不过这种操作极少，均摊下来时间仍为$O(1)$.

## 二、链表

链表分为单向和双向链表。单链表中每个节点指向链表中的下一个节点，双向链表中，同时需要指向下一个节点，也要保存指向上一个节点的信息。

与数组不同，无法在常数时间内访问链表的特定索引。意味着如果要访问第k个元素，则需要迭代访问k个元素。

它的好处，在于你可以在常数时间内插入或者删除一个元素。

### 2.1 创建链表

### 2.2 删除单向链表中的节点

给定节点n，找到其前驱节点prev,将prev.next改为n.next,如果是双向链表，还要更新n.next，n.next.prev设置为n.prev。有几点需要注意:

- 检查空指针。
- 必要时更新表头或者表尾节点。

### 2.3 快行指针

同时使用两个指针迭代访问链表，其中一个比另一个超前。快指针往往先行，或者与慢指针相差固定的步数。

## 三、栈与队列

### 3.1 实现栈

栈：存放数据，后进先出。
基本操作：

- pop 移除栈顶元素
- push 栈顶加入元素
- peek 返回栈顶元素
- isEmpty 是否为空

**栈也无法在常数时间内访问第i个元素**。

### 3.2 队列

队列：先进先出。
基本操作：

- add
- remove
- peek
- isEmpty
  
队列也可以用链表实现。只要元素是从链表的相反两端添加和删除，链表和队列的本质是相同的。

## 四、树

树：由节点构成的数据结构。

- 每棵树都有一个根节点。
- 根节点有0个或者多个子节点
- 每个子节点有0个或者多个子节点。

树中不应当有环路。

### 4.1 树的类型

#### 4.1.1 二叉树

每个节点至多有两个子节点。没有子节点的节点叫叶节点。

#### 4.1.2 二叉搜索树

属于二叉树，又满足以下属性：
全部左子孙节点<= 节点 <= 全部右子孙节点

一般不能有重复的值，对任意节点，其左子孙节点小于等于当前节点，当前节点又小于等于所有所有右子孙节点。

#### 4.1.3 平衡树

常见的是红黑树和AVL树。

#### 4.1.4 完整二叉树

属于二叉树。又满足除了最后一层外，树的每一层都被完全填满，树的最后一层是从左到右填充的。

#### 4.1.5 满二叉树

属于二叉树，同时又满足每个节点都有0个或者2个子节点，不存在只有一个子节点的节点。

#### 4.1.6 完美二叉树

既是完整二叉树，又是满二叉树。
虽有叶节点都处于同一层，此层包含最大的节点数。
必须正好有$2^k -1$个节点才能是完美二叉树、

### 4.2 二叉树遍历

#### 4.2.1 中序

先访问左子树，访问根节点，最后访问右子树。

#### 4.2.2 先序遍历

访问根节点，访问左子树，再访问右子树。

#### 4.2.3 后续遍历

访问左子树，访问右子树，访问根节点。

### 4.3 二叉堆

小顶堆，大顶堆。大顶堆，元素是将序排列而不是升序排列。

小顶堆，是一棵完整二叉树。除了底层右边的元素，树的每层都被填满了，每个节点都小于其子节点，根是树中最小的元素。

有两个关键操作，insert和extract_min。

#### 4.3.1 插入

向最小堆中插入元素的时候，总是从底部开始。从最右边的节点开始插入，保持树的完整性。
然后通过与其祖先节点做比较来修复树，直到找到合适的位置。

#### 4.3.2 提取最小元素

简单：它总在最顶部。棘手的是如何删除它。
首先，删除最小元素并将其与堆中最后一个元素（最底层最右边）交换，然后向下传递这个元素，不断使其与自身子节点之一交换，直到恢复最小堆。

### 4.4 单词查找树(先序树)

## 五、图

树实际上是图的一种，树是没有环路的连通图。图是节点与节点之间边的集合。

- 分为有向图和无向图。
- 图可以包括多个相互隔离的子图。如果任意节点直接都存在一条路径，那么该图又叫连通图
- 图也可以包括环路，无环图是指没有环路的图。
  
### 5.1 图的表示

#### 5.1.1 邻接链表法

每个顶点存储一列相邻的顶点。在无向图中，边会被存储两遍，在a的邻接顶点中存储一遍，在b的邻接顶点中存储一遍。

#### 5.1.2 邻接矩阵发

邻接矩阵是NxN的布尔型矩阵，[i][j]=true表示，i到j之间有一条边，当然也可以用整数型矩阵，0和1代表有无连接。

在无向图中，邻接矩阵是对称的。有向图中不一定。

在邻接链表中可以方便迭代一个节点的相邻接点，在临界矩阵表示法中，需要迭代所有节点才能找出某个节点的相邻节点。

### 5.2 图的搜索

深度优先搜索（DFS）、广度优先搜索(BFS)。

#### 5.2.1 深度优先搜索

以根节点为起始点，完整搜索一个分支之后，再搜索另一个分支，所谓先向深度方向搜索，再向广度方向搜索。

先访问节点a，然后遍历访问的a的每个相邻节点，在访问a的相邻接点b的时候，我们会继续访问a的其他相邻节点之前，先访问b的所有相邻接点，也就是说在搜索a的其他子节点之前，会先穷尽搜索b的所有子节点。

前序和树的遍历的其他形式都是DFS，区别在于，对图实现算法的时候，需要检查节点是不是已经被访问过，如果不这么做，就可能陷入无限循环。

#### 5.2.2 广度优先搜索

以根节点为起始点，先搜索其相邻节点，再搜索相邻接点的子节点，先向广度方向搜索，再向深度方向搜索。

如果想要访问所有节点，或者访问最少的节点找到想要的节点，则DFS一般最简单。

如果想找到两个节点的最短路径，BFS一般更加适宜。

#### 5.2.3 双向搜索

用于查找起始节点和目的节点的最短路径。本质上是从起始节点和目的节点同时开始的两个广度优先搜索，当两个搜索相遇的时候，就找到了一条路径。

## 六、位操作

### 6.1 手工位操作

^表示异或（XOR），~表示取反或者否定（NOT）。

举例：

- 0110 + 0110 相当于0110 * 2, 也是相当于把0110左移一位。
- 0100  * 0011 ，0100 = 4，相当于把0011 左移两位，变成1100
- 1101 ^ （~1101） 一个比特与对它取反的值做异或，结果总是1，因此a^(~a)的结果是一串1.
- 1011 & （~0 << 2） ~0的值是一串1，所以~0 << 2的结果是一串1后面跟2个0，将这个值与另一个值进行位于操作，相当于把这个值的后2位清0.

### 6.2 位操作原理和技巧

1s代表一串1 0s代表一串0

```java
x ^ 0s = x
x & 0s = 0
x | 0s = x
x ^ 1s = ~x
x & 1s = x
x | 1s = 1s
x ^ x = 0
x & x = x
x | x = x
```

### 6.3 二进制补码和负数

计算机通常以二进制补码的方式存储整数。正数表示为自身，负数表示为绝对值的二进制补码（符号位是1，表示负数）。N位数（N是数字的位数，不包括符号位）的二进制补码是相对于$2^N$的数字的补码。

以4位整数-3为例，如果它一个4位数，一个位表示符号位，3位表示数值位，我们需要相对于$2^3 = 8$的补码。在相对于8的情况下，3(-3的绝对值)的补码是5，5用二进制表示为101。因此，-3表示为4位则是1101，第一位是符号位。

### 6.4 算术右移和逻辑右移

算术右移等同于除以2，逻辑右移就是我们看到的移动数位的操作。
逻辑右移中，移动数位并将0放到最高位。用$>>>$表示，也叫无符号右移。
算术右移，把数位移动之后，用符号位填充最高位，相当于除以2.

### 6.5 常见位操作

#### 6.5.1 获取数位

该方法将1左移i位，得到形如00 010 000的值，接着对这个值与num执行"位与"。从而将i位之外的所有位都清0，最后检查该记过是不是0，不为0说明i位是1，否则i位是0。

```java
boolean getBit(int num , int i){
    return ((num & (1 << i )) != 0);
}
```

### 6.5.2 设置数位

setBit先把1左移i位，得到形如00 010 000这样的值，对这个值和num进行位或，这样只会改变i位的值，该掩码i位除外的值均为0，不会影响其他位。

```java
setBit(int num , int i){
    return num | ( 1 << i);
}
```

### 6.5.3 清零数位

与设置数位相反，把1左移i位，得到类似这样的数字00 010 000，然后对其取反，得到形如11 101 111 这样的值，对num进行位与，这样只会清0num的第i位，其余不变

```java
int clearBit(int num , int i){
    int mask = ~( 1 << i);
    return num & mask;
}
```

如果要清零最高位到第i位的所有数位，需要创建一个第i位是1的掩码（1 << i），然后将其减1并得到一串第一部分全是0，第二部分全是1的数字，之后将其与num执行位与，就得到了包留后i位的数字。

```java
int clearBitsMSBthroughI(int num , int i ){
    int mask = ( 1 << i) -1;
    return  num & mask;
}
```

如果要清零第i位到最后一位所有数位，需要一串1构成的数字(也就是-1)，将其左移i+1位，如此便得到一个前面一串是1，后面一串是0的数字，之后将其与num执行位与，就得到了包留后i位的数字。

```java
int clearBitsMSBthroughI(int num , int i ){
    int mask = ( -1 << (i+1)) ;
    return  num & mask;
}
```

### 6.5.4 更新数位

将第i位的值设置为v，首先用诸如11 101 111的掩码将num的第i位清零，然后将待写入的v左移i位，得到一个i位是v但是其余位都是0的数，最后对之前取得的两个结果位或，v为1则将num的i位设置为1，否则仍是0。

```java
int updateBit(int num , int i , boolean bitsIsOne){
    int value = bitsIsOne ? 1 : 0;
    int mask = ~( 1 << i) ;
    return  (num & mask) | (value << i);
}
```

