# <center>G1基本概念</center>

内存分配和垃圾回收是不可分隔的，单独拖出来说垃圾回收是没有意义的。

## 一、内存分配

### 2.1 分区

分区-Heap Region HR，也称为堆分区，是G1堆和操作系统交互的最小管理单位。G1的分区类型可以分为四类:

- 自由分区。Free Heap Region,FHR
- 新生代分区。Young Heap Region,YHR
    - Eden
    - Survivor
- 大对象分区。Humongous Heap Region, HHR
  - 大对象头分区
  - 大对象连续分区 
- 老生代分区。old Heap Region,OHR

HR大小直接会影响内存分配和回收效率。如果过大，则会在分配的时候效率高，回收的时候就会花费时间过长。如果太小，则导致分配效率低下。

为了达到分配和回收的平衡，HR有一个上限和下限。目前上限是32M下限是1M。默认情况下，整个堆分为2048个HR，该值可以自动根据最小堆分区大小计算得出。HR大小可以由以下方式确定：

- 参数G1HeapRegionSize指定大小，参数默认是0
- 启发式推断，即在不指定HR大小的时候，由G1启发式推断HR大小。

启发式推断，根据堆空间最大值和最小值，以及HR个数推断。设置InintialHeapSize（默认为0）等价于设置Xms，设置MaxHeapSize（默认96M）等价于设置Xmx。堆分区默认大小计算方式在HeapRegion.cpp的setup_heap_region_size方法。

由此可见，按照默认值计算,G1可管理的内存为最大：2048 * 32MB =64G。
假设设置XMXs=32g XMX=128G,则每个堆分区大小为32M，分区的个数从1024-4096个。

**G1中，大对象不使用新生代空间，直接进入老生代**
那多大的对象算是大对象呢？region_size的一半。

### 2.2 新生代大小

新生代大小是指新生代内存空间大小。新生代大小按照分区组织，受限计算整个新生代大小，再根据计算方法可以计算分区大小，相除得到需要多少个分区。

G1中增加了两个参数，G1MaxNewSizePercent和G1NewSizePercent控制新生代大小。

- 如果设置新生代最大值MaxNewSize和最小值NewSize，可以根据他们计算新生代包含的最大分区和最小分区。xmn等价于设置了maxNewSize和newSize且二者相等。
- 如果既设置了最大值和最小值，又设置了NewRatio，则忽略NewRatio。
- 如果没有设置最大值和最小值，但是设置了NewRatio，则新生代的最大值和最小值相同，且是整个对空间/NewRation+1
- 如果没有设置新生代最大值和最小值，或者只设置了其中一个，那么G1将根据参数G1MaxNewSizePercent（默认60）和G1NewSizePercent（默认5）占整个堆空间的比例来计算

如果G1推算出来最大值和最小值相等，则说明新生代不会动态改变，又意味着G1在后续对新生代垃圾回收的时候可能不能满足期望停顿时间。

如果G1是启发式推断新生代的大小，新生代变化的时候如何实现？使用一个分区列表，扩张的时候如果有空闲的分区列表，则可以直接把空闲分区加入到新生代的分区列表，如果没有的话则分配新的分区，然后再加到新生代分区列表中。
G1有一个专门的线程抽样处理预测新生代列表长度应该多大，动态调整。

**分配新区的时候如何扩展一次扩展多少**

G1是自适应扩展。-XX:GCTimeRatio表示GC与应用的耗费时间比，G1中默认是9。
计算方式：_gc_overhead_perc=100.0 * (1.0/(1.0 + GCTimeRatio))
即G1中GC时间与应用时间占比不超过10%时不需要动态扩展，GC超过这个阈值的10%，可以动态扩展。
扩展时有一个参数G1ExpandByPercentOfAvailable(默认20)来控制一次扩展的比例，每次都至少从未提交的内存中申请20%，有下限要求（一次申请的内存不能少于1M，最多是当前已分配的一倍）。

### 2.3 G1停顿模型

G1是响应优先的GC算法，可以设定GC过程中期望停顿的时间，由MaxGcPauseMillis控制，默认值200ms。但是这个值不是硬性条件，知识期望值，G1会努力在这个目标停顿时间完成垃圾回收，但是不能保证，也可能完不成（比如我们设置了太小时间停顿，新生代太大等等）。